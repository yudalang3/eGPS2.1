package module.mutationpre;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.util.List;
import java.util.Optional;

import javax.swing.BorderFactory;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;

import org.jdesktop.swingx.JXTaskPane;
import org.jdesktop.swingx.JXTaskPaneContainer;

import egps2.UnifiedAccessPoint;
import egps2.frame.ModuleFace;
import module.mutationpre.gui.LeftConveOperationPanel;
import module.mutationpre.model.DrawMutationElement;
import egps2.modulei.AdjusterFillAndLine;
import egps2.modulei.IInformation;
import egps2.modulei.IModuleLoader;

@SuppressWarnings("serial")
public class GenomicMutationPresenterMain extends ModuleFace implements AdjusterFillAndLine {

	private SimplestModuleController controller = new SimplestModuleController(this);
	private MyWorkStudio myWorkStudio = new MyWorkStudio();

	Font defaultTitleFont = UnifiedAccessPoint.getLaunchProperty().getDefaultTitleFont();

	ImportDataHandler importDataHandler = new ImportDataHandler(myWorkStudio, controller);
	
	private JSplitPane mainSplitPanel;

	GenomicMutationPresenterMain(IModuleLoader moduleLoader) {
		super(moduleLoader);
		setLayout(new BorderLayout(0, 0));

		mainSplitPanel = new JSplitPane();
		mainSplitPanel.setBorder(BorderFactory.createEmptyBorder());		
		JXTaskPaneContainer taskPaneContainer = new JXTaskPaneContainer();
		taskPaneContainer.setBackground(Color.WHITE);
		taskPaneContainer.setBackgroundPainter(null);

		JXTaskPane convenietOperationTaskPanel = getConvenietOperationTaskPanel();
		taskPaneContainer.add(convenietOperationTaskPanel);

		JScrollPane tempJScrollPane = new JScrollPane(taskPaneContainer);

		mainSplitPanel.setLeftComponent(tempJScrollPane);
		mainSplitPanel.setRightComponent(myWorkStudio);		
		
		add(mainSplitPanel, BorderLayout.CENTER);

		controller.setWorkStudio(myWorkStudio);

	}

	private JXTaskPane getConvenietOperationTaskPanel() {
		JXTaskPane tmpJxTaskPane = new JXTaskPane();
		tmpJxTaskPane.setFont(defaultTitleFont);
		tmpJxTaskPane.setTitle("Convenient Operation");
		LeftConveOperationPanel operationPanel = new LeftConveOperationPanel(controller);
		tmpJxTaskPane.add(operationPanel);

		return tmpJxTaskPane;
	}

	public SimplestModuleController getController() {
		return controller;
	}

	@Override
	public boolean closeTab() {
		return false;
	}

	@Override
	public void changeToThisTab() {

	}

	@Override
	public boolean canImport() {
		return true;
	}

	@Override
	public void importData() {
		importDataHandler.doUserImportAction();
	}

	@Override
	public boolean canExport() {
		return true;
	}

	@Override
	public void exportData() {
		getController().saveViewPanelAs();
	}

	@Override
	public String[] getFeatureNames() {
		return new String[] { "Plot the mutations of sequences", "Auto fit frame refresh" };
	}

	@Override
	protected void initializeGraphics() {
		importDataHandler.doUserImportAction();
	}

	@Override
	public IInformation getModuleInfo() {
		IInformation iInformation = new IInformation() {

			@Override
			public String getWhatDataInvoked() {
				return "The data is loading from the import dialog.";
			}

			@Override
			public String getSummaryOfResults() {
				return "The presentation of mutations is generated by the eGPS software.";
			}
		};
		return iInformation;
	}

//	@Override
//	public Optional<Dimension> couldAdjustSize() {
//		return Optional.empty();
//	}
//
//	@Override
//	public Optional<Integer> couldRotation() {
//		return Optional.empty();
//	}
//
//	@Override
//	public Optional<Dimension> couldAdjustPosition() {
//		List<DrawMutationElement> selectedMutationElement = controller.getDrawProperties().getSelectedMutationElement();
//		if (selectedMutationElement.isEmpty()) {
//			return Optional.empty();
//		} else {
//			DrawMutationElement drawMutationElement = selectedMutationElement.get(0);
//			Dimension dimension = new Dimension(drawMutationElement.rectangle.x, drawMutationElement.rectangle.y);
//			return Optional.of(dimension);
//		}
//		
//		
//	}
//
//	@Override
//	public void adjustSize(int newWidth, int newHeight) {
//
//	}
//
//	@Override
//	public void adjustRotation(int newAngle) {
//
//	}
//
//	@Override
//	public void adjustPosition(int hori, int vert) {
//		List<DrawMutationElement> selectedMutationElement = controller.getDrawProperties().getSelectedMutationElement();
//		for (DrawMutationElement drawMutationElement : selectedMutationElement) {
////			Rectangle rectangle = drawMutationElement.rectangle;
////			drawMutationElement.rectangle.setFrame(hori, vert, rectangle.width, rectangle.height);
//		
//			drawMutationElement.rotationPoint.x = hori;
//			drawMutationElement.rotationPoint.y = vert;
//		
//		}
//		
//		
//		controller.heavyRefresh();
//	}

	@Override
	public Optional<Color> couldSetFillColor() {
		List<DrawMutationElement> selectedMutationElement = controller.getDrawProperties().getSelectedMutationElement();
		if (selectedMutationElement.isEmpty()) {
			return Optional.empty();
		} else {
			return Optional.of(selectedMutationElement.get(0).color);
		}

	}

	@Override
	public Optional<Font> couldSetFont() {
		return Optional.empty();
	}

	@Override
	public Optional<Color> couldSetLineColor() {
		return Optional.empty();
	}

	@Override
	public Optional<Integer> couldSetLineThickness() {
		return Optional.empty();
	}

	@Override
	public void adjustFillColor(Color newCol) {
		List<DrawMutationElement> selectedMutationElement = controller.getDrawProperties().getSelectedMutationElement();
		for (DrawMutationElement drawMutationElement : selectedMutationElement) {
			drawMutationElement.color = newCol;
		}
		controller.heavyRefresh();
	}

	@Override
	public void adjustFillFont(Font newFont) {

	}

	@Override
	public void adjustLineColor(Color newCol) {

	}

	@Override
	public void adjustLineThickness(int newThickNess) {

	}
}
