package module.evolview.phylotree.visualization.layout;import java.awt.BasicStroke;import java.awt.Color;import java.awt.FontMetrics;import java.awt.Graphics2D;import java.awt.RenderingHints;import java.awt.geom.Arc2D;import java.awt.geom.GeneralPath;import java.awt.geom.Point2D.Double;import java.util.LinkedList;import java.util.List;import java.util.function.Function;import module.evolview.gfamily.work.gui.DrawUtil;import module.evolview.gfamily.work.gui.tree.PhylogeneticTreePanel;import module.evolview.gfamily.work.gui.tree.annotation.DrawPropInternalNode2LeafAnno;import module.evolview.gfamily.work.gui.tree.annotation.DrawPropInternalNodeInsituAnno;import module.evolview.gfamily.work.gui.tree.annotation.DrawPropOutterSidewardAnno;import module.evolview.gfamily.work.gui.tree.annotation.OutterSidewardLocation;import module.evolview.phylotree.visualization.graphics.struct.NodeType;import module.evolview.model.tree.AnnotationsProperties;import module.evolview.model.tree.AnnotationsProperties4LinageType;import module.evolview.phylotree.visualization.graphics.struct.CircularLayoutProperty;import module.evolview.model.tree.GraphicsNode;import module.evolview.model.tree.TreeLayoutProperties;import module.evolview.phylotree.visualization.graphics.struct.util.GraphicTreePropertyCalculator;import module.evolview.phylotree.visualization.graphics.struct.util.GraphicTreePropertyCalculator.LongestRoot2leafBean;import graphic.engine.guicalculator.GuiCalculator;import module.evolview.phylotree.visualization.graphics.struct.TreeDecideUtil;public class CircularPhylo extends CicularLayout {	private int leafLoop = 0;	private double increseDeg;	private Arc2D.Double arcDrawer = new Arc2D.Double();	private int globalStartDegree;	protected double biggestCircleRadicus;	protected int centerX;	protected int centerY;	protected int recursiveCalculateStartLength;	public CircularPhylo(TreeLayoutProperties controller, GraphicsNode rootNode,			PhylogeneticTreePanel phylogeneticTreePanel) {		super(controller, rootNode, phylogeneticTreePanel);	}	@Override	public void calculateForPainting(int width, int height) {		beforeCalculate(width, height);		leafLoop = 0;				int workWidth = blankArea.getWorkWidth(width);		int workHeight = blankArea.getWorkHeight(height);		biggestCircleRadicus = 0.5 * Math.min(workWidth,workHeight );		calculateRatioAndChooseStartLength();		centerX = (int) (currentWidth / 2);		centerY = (int) (currentHeight / 2);		CircularLayoutProperty circularLayoutPropertiy = treeLayoutProperties.getCircularLayoutPropertiy();		globalStartDegree = circularLayoutPropertiy.getGlobalStartDegree();		int totolDeg = circularLayoutPropertiy.getGlobalExtendDegree();				int leafNumber4computation =  GraphicTreePropertyCalculator.getLeafNumber(rootNode);		if (totolDeg < 360) {			leafNumber4computation --;		}				increseDeg = totolDeg / (double) leafNumber4computation;		GraphicsNode node = rootNode;		recursiveCalculate(node, recursiveCalculateStartLength);		// set root properties!		node.setXParent(centerX);		node.setYParent(centerY);		Double tt = GuiCalculator.calculateCircularLocation(node.getAngleIfNeeded(),				node.getRadicusIfNeeded(), centerX, centerY);		node.setXSelf(tt.x);		node.setYSelf(tt.y);		this.scaleBarProperty.setIfDrawScaleBar(true);		afterCalculation();	}	@Override	protected void configurateMainAnnotation(AnnotationsProperties annotationsProperties) {		List<DrawPropInternalNode2LeafAnno> internalNode2LeafAnnos = annotationsProperties.getInternalNode2LeafAnnos();		for (DrawPropInternalNode2LeafAnno tt : internalNode2LeafAnnos) {			if (tt.shouldConfigurateAndPaint()) {				GraphicsNode currentGraphicsNode = tt.getCurrentGraphicsNode();				List<GraphicsNode> leaves = GraphicTreePropertyCalculator.getLeaves(currentGraphicsNode);				GraphicsNode firstLeaf = leaves.get(0);				GraphicsNode lastLeaf = leaves.get(leaves.size() - 1);				double innerRadicus = currentGraphicsNode.getRadicusIfNeeded();				double xSelf = firstLeaf.getXSelf();				double ySelf = firstLeaf.getYSelf();				double startDeg = firstLeaf.getAngleIfNeeded();				double endDeg = lastLeaf.getAngleIfNeeded();				double extentDeg = endDeg - startDeg;				GeneralPath sector = new GeneralPath();				sector.moveTo(xSelf, ySelf);				Arc2D.Double arc1 = new Arc2D.Double();				arc1.setArcByCenter(centerX, centerY, biggestCircleRadicus, startDeg, extentDeg, Arc2D.OPEN);				sector.append(arc1, true);				arc1.setArcByCenter(centerX, centerY, innerRadicus, endDeg, -extentDeg, Arc2D.OPEN);				sector.append(arc1, true);				sector.closePath();				tt.setDrawShape(sector);			}		}		// 这个注释要特殊处理		// List<DrawPropLeafNameAnno> leafNameAnnos =		// annotationsProperties.getLeafNameAnnos();		annotationsProperties.configurateLeafNamesAnnotaion(false);		List<DrawPropOutterSidewardAnno> outterSidewardAnnos = annotationsProperties.getOutterSidewardAnnos();		for (DrawPropOutterSidewardAnno tt : outterSidewardAnnos) {			if (tt.shouldConfigurateAndPaint()) {				GraphicsNode currentGraphicsNode = tt.getCurrentGraphicsNode();				List<GraphicsNode> leaves = GraphicTreePropertyCalculator.getLeaves(currentGraphicsNode);				GraphicsNode firstLeaf = leaves.get(0);				GraphicsNode lastLeaf = leaves.get(leaves.size() - 1);				double startDeg = firstLeaf.getAngleIfNeeded();				double endDeg = lastLeaf.getAngleIfNeeded();				double extentDeg = endDeg - startDeg;				double radicus = getRadicusForAnnotation(leaves.toArray(new GraphicsNode[1]));				Arc2D.Double arc1 = new Arc2D.Double();				arc1.setArcByCenter(centerX, centerY, radicus + 10, startDeg, extentDeg, Arc2D.OPEN);				Double point = GuiCalculator.calculateCircularLocation(startDeg + 0.5 * extentDeg, radicus + 20,						centerX, centerY);				tt.setTextLocationAndShape(point.getX(), point.getY(), arc1);			}		}		List<DrawPropInternalNodeInsituAnno> internalNode2LeafInsituAnnos = annotationsProperties				.getInternalNode2LeafInsituAnnos();		for (DrawPropInternalNodeInsituAnno tt : internalNode2LeafInsituAnnos) {			if (tt.shouldConfigurateAndPaint()) {				tt.configurate();			}		}	}	@Override	protected void configurateLinageTypeAnnotation(AnnotationsProperties4LinageType annotationsProperties) {		GraphicsNode[] leavesArrayWithoutOutgroup = GraphicTreePropertyCalculator.getLeaves(rootNode)				.toArray(new GraphicsNode[1]);		double radicus = getRadicusForAnnotation(leavesArrayWithoutOutgroup);		linageTypeSidewardAnnotationCalculator = new Function<LinkedList<GraphicsNode>, OutterSidewardLocation>() {			@Override			public OutterSidewardLocation apply(LinkedList<GraphicsNode> t) {				GraphicsNode firstLeaf = t.getFirst();				GraphicsNode lastLeaf = t.getLast();				double startDeg = firstLeaf.getAngleIfNeeded();				double endDeg = lastLeaf.getAngleIfNeeded();				double extentDeg = endDeg - startDeg;				if (extentDeg < 1) {					extentDeg = 1;				}				Arc2D.Double arc1 = new Arc2D.Double();				arc1.setArcByCenter(centerX, centerY, radicus + 10, startDeg, extentDeg, Arc2D.OPEN);				Double point = GuiCalculator.calculateCircularLocation(startDeg + 0.5 * extentDeg, radicus + 20,						centerX, centerY);				OutterSidewardLocation ret = new OutterSidewardLocation();				ret.setShape(arc1);				ret.setTextX((float) point.getX());				ret.setTextY((float) point.getY());				return ret;			}		};		linageTypeNode2LeafAnnotationCalculator = new Function<LinkedList<GraphicsNode>, OutterSidewardLocation>() {			@Override			public OutterSidewardLocation apply(LinkedList<GraphicsNode> t) {				GraphicsNode firstLeaf = t.getFirst();				GraphicsNode lastLeaf = t.getLast();				GraphicsNode mrca = GraphicTreePropertyCalculator.getMostRecentCommonAnsester(firstLeaf, lastLeaf);				double innerRadicus = mrca.getRadicusIfNeeded();				double xSelf = firstLeaf.getXSelf();				double ySelf = firstLeaf.getYSelf();				double startDeg = firstLeaf.getAngleIfNeeded();				double endDeg = lastLeaf.getAngleIfNeeded();				double extentDeg = endDeg - startDeg;				if (extentDeg < 1) {					extentDeg = 1;					startDeg -= 1;					endDeg = startDeg + 1;				}				GeneralPath sector = new GeneralPath();				sector.moveTo(xSelf, ySelf);				Arc2D.Double arc1 = new Arc2D.Double();				arc1.setArcByCenter(centerX, centerY, biggestCircleRadicus, startDeg, extentDeg, Arc2D.OPEN);				sector.append(arc1, true);				arc1.setArcByCenter(centerX, centerY, innerRadicus, endDeg, -extentDeg, Arc2D.OPEN);				sector.append(arc1, true);				sector.closePath();				OutterSidewardLocation ret = new OutterSidewardLocation();				Double point = GuiCalculator.calculateCircularLocation(startDeg + 0.5 * extentDeg - 1, radicus + 20,						centerX, centerY);				ret.setShape(sector);				ret.setTextX((float) point.getX());				ret.setTextY((float) point.getY());				return ret;			}		};				super.configurateLinageTypeAnnotation(annotationsProperties);	}	protected void calculateRatioAndChooseStartLength() {		double avaliableLength = biggestCircleRadicus - treeLayoutProperties.getRootTipLength();		LongestRoot2leafBean maxLengthOfRoot2LeafNoOutgroup = GraphicTreePropertyCalculator				.getMaxLengthOfRoot2Leaf(rootNode);		canvas2logicRatio = avaliableLength / maxLengthOfRoot2LeafNoOutgroup.getLength();		recursiveCalculateStartLength = (int) treeLayoutProperties.getRootTipLength();		configurateButtomScaleBarDrawProperty(maxLengthOfRoot2LeafNoOutgroup.getLength(),				maxLengthOfRoot2LeafNoOutgroup.getLeaf());	}	/**	 * 这里的real就是说是屏幕的长度！	 */	private void recursiveCalculate(GraphicsNode node, double cumulateRealBranchLengthExceptCurrent) {		double radicus = calculateRadicus(cumulateRealBranchLengthExceptCurrent, node);		// 这一行要比递归调用早！		node.setRadicusIfNeeded(radicus);		NodeType nodeType = TreeDecideUtil.decideNodeType(node, rootNode);		switch (nodeType) {		case LEAF:			node.setAngleIfNeeded(leafLoop * increseDeg + globalStartDegree);			assignLocation(node);			leafLoop++;			break;		default:			// internal first recursive			for (int i = 0; i < node.getChildCount(); i++) {				recursiveCalculate((GraphicsNode) node.getChildAt(i), radicus);			}			// 这一行要比递归调用晚！			double angle = averageValueOfAngleFromChildren(node);			node.setAngleIfNeeded(angle);			if (nodeType != NodeType.ROOT) {				assignLocation(node);			}			break;		}	}	protected double calculateRadicus(double cumulateRealBranchLengthExceptCurrent, GraphicsNode node) {		double radicus = cumulateRealBranchLengthExceptCurrent + node.getDisplayedBranchLength() * canvas2logicRatio;		return radicus;	}	/**	 * 对于当前的node来说: angle和radicus是这个循环赋值的！	 */	protected void assignLocation(GraphicsNode node) {		double currentNodeAngle = node.getAngleIfNeeded();		Double tt = GuiCalculator.calculateCircularLocation(currentNodeAngle, node.getRadicusIfNeeded(), centerX,				centerY);		node.setXSelf(tt.x);		node.setYSelf(tt.y);		// System.out.print(tt[0]+"\t"+tt[1]+"\t");		GraphicsNode parent = (GraphicsNode) node.getParent();		tt = GuiCalculator.calculateCircularLocation(currentNodeAngle, parent.getRadicusIfNeeded(), centerX, centerY);		node.setXParent(tt.x);		node.setYParent(tt.y);		// System.out.println(tt[0]+"\t"+tt[1]+"\t"+currentNodeAngle);	}	private double averageValueOfAngleFromChildren(GraphicsNode base) {		double sum = 0.0;		int size = base.getChildCount();//		for (int i = 0; i < size; i++) {//			sum += ((GraphicsNode) base.getChildAt(i)).getAngleIfNeeded();//		}				int firstChildIndex = 0;		int lastChildIndex = size - 1;				sum += ((GraphicsNode) base.getChildAt(firstChildIndex)).getAngleIfNeeded();		sum += ((GraphicsNode) base.getChildAt(lastChildIndex)).getAngleIfNeeded();			return sum / size;	}	@Override	protected void specificTreeDrawingProcess(Graphics2D g2d) {		//暂时先不绘制这个辅助定位的过程//		drawBranchLengthReferenceAxis(g2d);	}	/**	 * 同 RectPhyloLayout，因为它绘制在底部！	 * 	 * @param g2d	 */	protected void drawBranchLengthReferenceAxis(Graphics2D g2d) {		if (!is4AnnotationDialog && treeLayoutProperties.isShowAxisBar()) {						g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);			double leftBlankLength = recursiveCalculateStartLength;			g2d.setColor(Color.decode("#E9E4E6"));			g2d.setFont(treeLayoutProperties.getAxisFont());			g2d.setStroke(new BasicStroke(1f));			double width = biggestCircleRadicus - recursiveCalculateStartLength;			FontMetrics fontMetrics = g2d.getFontMetrics();//		int fontHeight = fontMetrics.getHeight();			List<java.lang.Double> displayeDoubles = buttomScaleBarDrawProperty.getDisplayeDoubles();			List<String> displayedStrings = buttomScaleBarDrawProperty.getDisplayedStrings();			int count = displayedStrings.size();			for (int i = 0; i < count; i++) {				java.lang.Double double1 = displayeDoubles.get(i);				int radicus = (int) (leftBlankLength + double1 * width);				int diameter = 2 * radicus;				g2d.drawOval(centerX - radicus, centerY - radicus, diameter, diameter);				String str = displayedStrings.get(i);				float yStr = (float) (centerY + radicus);				float xStr = (float) (centerX - 0.5 * fontMetrics.stringWidth(str));				g2d.drawString(str, xStr, yStr);			}		}	}	@Override	protected void leafLineDrawingProcess(Graphics2D g2d, GraphicsNode node) {		drawEachLine(g2d, node);			}		@Override	protected void rootDrawingProcess(Graphics2D g2d, GraphicsNode node) {		DrawUtil.drawRootTip(g2d, node, treeLayoutProperties);//		int halfHH = (int) biggestCircleRadicus;//		g2d.setColor(new Color(200, 200, 200, 50));//		g2d.fillOval(centerX - halfHH, centerY - halfHH, halfHH + halfHH,  halfHH + halfHH);	}		@Override	protected void innerNodeDrawingProcess(Graphics2D g2d, GraphicsNode node) {		drawEachLine(g2d, node);	}//	private void recursiveDraw(Graphics2D g2D, GraphicsNode node) {//		NodeType nodeType = TreeDecideUtil.decideNodeType(node, rootNode);//		switch (nodeType) {//		case LEAF://			if (!node.hideNode()) {//				drawEachLine(g2D, node);//				drawEachLeafNameGraphicsIfNeeded(g2D, node, node.getXSelf(), node.getYSelf());//			}//			break;//		default://			if (nodeType == NodeType.ROOT) {//				DrawUtil.drawRootTip(g2D, node, treeLayoutProperties);//			} else {//				if (!node.hideNode()) {//					drawEachLine(g2D, node);//				}//			}//			for (int i = 0; i < node.getChildCount(); i++) {//				recursiveDraw(g2D, node.getChildAt(i));//			}//			break;//		}//	}	protected void drawEachLine(Graphics2D g2d, GraphicsNode node) {		commonDrawEachUnit(g2d, node, true);		GraphicsNode parent = (GraphicsNode) node.getParent();		double radicus = parent.getRadicusIfNeeded();		double currentAngle = node.getAngleIfNeeded();		double parentAngle = parent.getAngleIfNeeded();		arcDrawer.setArcByCenter(centerX, centerY, radicus, Math.min(currentAngle, parentAngle),				Math.abs(currentAngle - parentAngle), Arc2D.OPEN);		g2d.draw(arcDrawer);	}}