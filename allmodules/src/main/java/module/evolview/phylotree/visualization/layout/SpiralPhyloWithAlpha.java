package module.evolview.phylotree.visualization.layout;import java.awt.BasicStroke;import java.awt.Color;import java.awt.Graphics2D;import java.awt.RenderingHints;import java.awt.geom.GeneralPath;import java.awt.geom.Point2D.Double;import java.util.LinkedList;import java.util.List;import java.util.function.Function;import module.evolview.gfamily.work.gui.DrawUtil;import module.evolview.gfamily.work.gui.tree.PhylogeneticTreePanel;import module.evolview.gfamily.work.gui.tree.annotation.DrawPropInternalNode2LeafAnno;import module.evolview.gfamily.work.gui.tree.annotation.DrawPropInternalNodeInsituAnno;import module.evolview.gfamily.work.gui.tree.annotation.DrawPropOutterSidewardAnno;import module.evolview.gfamily.work.gui.tree.annotation.OutterSidewardLocation;import module.evolview.phylotree.visualization.graphics.struct.NodeType;import module.evolview.model.tree.AnnotationsProperties;import module.evolview.model.tree.AnnotationsProperties4LinageType;import module.evolview.model.tree.GraphicsNode;import module.evolview.phylotree.visualization.graphics.struct.SprialLayoutProperty;import module.evolview.model.tree.TreeLayoutProperties;import module.evolview.phylotree.visualization.graphics.struct.util.GraphicTreePropertyCalculator;import module.evolview.phylotree.visualization.graphics.struct.util.GraphicTreePropertyCalculator.LongestRoot2leafBean;import graphic.engine.guicalculator.GuiCalculator;import module.evolview.phylotree.visualization.graphics.struct.TreeDecideUtil;public class SpiralPhyloWithAlpha extends SprialLayout {	/** Global beta */	private double beta = 4;	/** 多出来的参数！ */	protected double maxAlpha;		private GeneralPath generalPath = new GeneralPath(GeneralPath.WIND_EVEN_ODD, 1000);	public SpiralPhyloWithAlpha(TreeLayoutProperties controller, GraphicsNode rootNode,			PhylogeneticTreePanel phylogeneticTreePanel) {		super(controller, rootNode, phylogeneticTreePanel);	}	@Override	protected void beforeCalculate(int width, int height) {		super.beforeCalculate(width, height);		SprialLayoutProperty circularLayoutPropertiy = treeLayoutProperties.getSprialLayoutPropertiy();		globalStartDegree = circularLayoutPropertiy.getGlobalStartDegree();		final int GAP_SIZE = circularLayoutPropertiy.getGapSize();		double twoPi = 2 * Math.PI;		int globalExtendingDegree = circularLayoutPropertiy.getGlobalExtendingDegree();		beta = (biggestCircleRadicus - treeLayoutProperties.getRootTipLength() - GAP_SIZE)				/ (twoPi + Math.toRadians(globalExtendingDegree));		double betaTimesTwoPi = beta * twoPi;		maxAlpha = treeLayoutProperties.getRootTipLength() + betaTimesTwoPi - GAP_SIZE;		LongestRoot2leafBean maxLengthOfRoot2LeafNoOutgroup = GraphicTreePropertyCalculator				.getMaxLengthOfRoot2Leaf(rootNode);		canvas2logicRatio = (betaTimesTwoPi - GAP_SIZE) / maxLengthOfRoot2LeafNoOutgroup.getLength();		configurateButtomScaleBarDrawProperty(maxLengthOfRoot2LeafNoOutgroup.getLength(),				maxLengthOfRoot2LeafNoOutgroup.getLeaf());	}	@Override	public void calculateForPainting(int width, int height) {		beforeCalculate(width, height);		GraphicsNode node = rootNode;		recursiveCalculate(node, 0);		// set root properties!		node.setXParent(centerX);		node.setYParent(centerY);		Double tt = GuiCalculator.calculateSpiralLocation(node.getRadicusIfNeeded(), beta, node.getAngleIfNeeded(),				centerX, centerY);		node.setXSelf(tt.x);		node.setYSelf(tt.y);		scaleBarProperty.setIfDrawScaleBar(true);		afterCalculation();	}	@Override	protected void configurateMainAnnotation(AnnotationsProperties annotationsProperties) {		List<DrawPropInternalNode2LeafAnno> internalNode2LeafAnnos = annotationsProperties.getInternalNode2LeafAnnos();		for (DrawPropInternalNode2LeafAnno tt : internalNode2LeafAnnos) {			if (tt.shouldConfigurateAndPaint()) {				GraphicsNode currentGraphicsNode = tt.getCurrentGraphicsNode();				List<GraphicsNode> leaves = GraphicTreePropertyCalculator.getLeaves(currentGraphicsNode);				GraphicsNode firstLeaf = leaves.get(0);				GraphicsNode lastLeaf = leaves.get(leaves.size() - 1);				double startDeg = firstLeaf.getAngleIfNeeded();				double lastDeg = lastLeaf.getAngleIfNeeded();				produceSprialRing(startDeg, lastDeg - startDeg, currentGraphicsNode.getRadicusIfNeeded(), beta,						maxAlpha, beta);				GeneralPath clone = (GeneralPath) generalPath.clone();				tt.setDrawShape(clone);			}		}		// 这个注释要特殊处理		// List<DrawPropLeafNameAnno> leafNameAnnos =		// annotationsProperties.getLeafNameAnnos();		annotationsProperties.configurateLeafNamesAnnotaion(false);		List<DrawPropOutterSidewardAnno> outterSidewardAnnos = annotationsProperties.getOutterSidewardAnnos();		for (DrawPropOutterSidewardAnno tt : outterSidewardAnnos) {			if (tt.shouldConfigurateAndPaint()) {				GraphicsNode currentGraphicsNode = tt.getCurrentGraphicsNode();				List<GraphicsNode> leaves = GraphicTreePropertyCalculator.getLeaves(currentGraphicsNode);				GraphicsNode firstLeaf = leaves.get(0);				GraphicsNode lastLeaf = leaves.get(leaves.size() - 1);				double startDeg = firstLeaf.getAngleIfNeeded();				double lastDeg = lastLeaf.getAngleIfNeeded();				GeneralPath clone = produceSprial(startDeg, lastDeg - startDeg, maxAlpha + 4, beta);				Double point = GuiCalculator.calculateSpiralLocation(maxAlpha + 1, beta, 0.5 * (startDeg + lastDeg),						centerX, centerY);				tt.setTextLocationAndShape(point.getX(), point.getY(), clone);			}		}		List<DrawPropInternalNodeInsituAnno> internalNode2LeafInsituAnnos = annotationsProperties				.getInternalNode2LeafInsituAnnos();		for (DrawPropInternalNodeInsituAnno tt : internalNode2LeafInsituAnnos) {			if (tt.shouldConfigurateAndPaint()) {				tt.configurate();			}		}	}	@Override	protected void configurateLinageTypeAnnotation(AnnotationsProperties4LinageType annotationsProperties) {		linageTypeSidewardAnnotationCalculator = new Function<LinkedList<GraphicsNode>, OutterSidewardLocation>() {			@Override			public OutterSidewardLocation apply(LinkedList<GraphicsNode> t) {				GraphicsNode firstLeaf = t.getFirst();				GraphicsNode lastLeaf = t.getLast();				double startDeg = firstLeaf.getAngleIfNeeded();				double endDeg = lastLeaf.getAngleIfNeeded();				double extentDeg = endDeg - startDeg;				if (extentDeg < 1) {					extentDeg = 1;					endDeg = startDeg + 1;				}				GeneralPath clone = produceSprial(startDeg, extentDeg, maxAlpha + 4, beta);				Double point = GuiCalculator.calculateSpiralLocation(maxAlpha + 1, beta, 0.5 * (startDeg + endDeg),						centerX, centerY);				OutterSidewardLocation ret = new OutterSidewardLocation();				ret.setShape(clone);				ret.setTextX((float) point.getX());				ret.setTextY((float) point.getY());				return ret;			}		};		linageTypeNode2LeafAnnotationCalculator = new Function<LinkedList<GraphicsNode>, OutterSidewardLocation>() {			@Override			public OutterSidewardLocation apply(LinkedList<GraphicsNode> t) {				GraphicsNode firstLeaf = t.getFirst();				GraphicsNode lastLeaf = t.getLast();				GraphicsNode mrca = GraphicTreePropertyCalculator.getMostRecentCommonAnsester(firstLeaf, lastLeaf);				double startDeg = firstLeaf.getAngleIfNeeded();				double lastDeg = lastLeaf.getAngleIfNeeded();				double extendDeg = lastDeg - startDeg;				if (extendDeg < 1) {					extendDeg = 1;					startDeg -= 0.5;					lastDeg = startDeg + extendDeg;				}				GeneralPath clone = produceSprialRing(startDeg, extendDeg, mrca.getRadicusIfNeeded(), beta, maxAlpha,						beta);				Double point = GuiCalculator.calculateSpiralLocation(maxAlpha + 1, beta, 0.5 * (startDeg + lastDeg) + 4,						centerX, centerY);				OutterSidewardLocation ret = new OutterSidewardLocation();				ret.setShape(clone);				ret.setTextX((float) point.getX());				ret.setTextY((float) point.getY());				return ret;			}		};		super.configurateLinageTypeAnnotation(annotationsProperties);	}	private void recursiveCalculate(GraphicsNode node, double cumulateBranchLengthExceptCurrent) {		double branchLen = cumulateBranchLengthExceptCurrent + node.getDisplayedBranchLength();		double realBranchLen = treeLayoutProperties.getRootTipLength() + branchLen * canvas2logicRatio;		NodeType nodeType = TreeDecideUtil.decideNodeType(node, rootNode);		switch (nodeType) {		case LEAF:			node.setAngleIfNeeded(leafLoop * increseDeg + globalStartDegree);			node.setRadicusIfNeeded(realBranchLen);			assignLocation(node);			leafLoop++;			break;		default:			// 这一行要比递归调用早！			node.setRadicusIfNeeded(realBranchLen);			// internal first recursive			for (int i = 0; i < node.getChildCount(); i++) {				recursiveCalculate((GraphicsNode)node.getChildAt(i), branchLen);			}			// 这一行要比递归调用晚！			double angle = averageValueOfAngleFromChildren(node);			node.setAngleIfNeeded(angle);			if (nodeType != NodeType.ROOT) {				assignLocation(node);			}			break;		}	}	/**	 * 对于当前的node来说: angle和radicus是这个循环赋值的！	 */	protected void assignLocation(GraphicsNode node) {		double currentNodeAngle = node.getAngleIfNeeded();		Double tt = GuiCalculator.calculateSpiralLocation(node.getRadicusIfNeeded(), beta, currentNodeAngle, centerX,				centerY);		node.setXSelf(tt.x);		node.setYSelf(tt.y);		// System.out.println("Current node angle: "+currentNodeAngle+"\tNode radicus:		// "+node.getRadicusIfNeeded()+" Point: "+tt.x+" "+tt.y);		GraphicsNode parent = (GraphicsNode) node.getParent();		tt = GuiCalculator.calculateSpiralLocation(parent.getRadicusIfNeeded(), beta, currentNodeAngle, centerX,				centerY);		node.setXParent(tt.x);		node.setYParent(tt.y);		// System.out.println("Parent radicus: "+parent.getRadicusIfNeeded()+" Point:		// "+tt.x+" "+tt.y);		// System.out.println(parent.getRadicusIfNeeded()+"		// "+node.getRadicusIfNeeded()+"		// ------------------------------------------------");	}		@Override	protected void specificTreeDrawingProcess(Graphics2D g2d) {//		SprialLayoutProperty circularLayoutPropertiy = treeLayoutProperties.getSprialLayoutPropertiy();//		double totolDeg = circularLayoutPropertiy.getGlobalExtendingDegree();//		produceSprialRing(0, totolDeg, treeLayoutProperties.getRootTipLength(), beta, maxAlpha, beta);//		g2d.setColor(Color.lightGray);//		g2d.draw(generalPath);//		g2d.setColor(new Color(12, 12, 5, 12));//		g2d.fill(generalPath);		drawButtomAxis(g2d);		//recursiveDraw(g2d, rootNode);		// draw the center of the circle//		g2d.setColor(Color.pink);//		g2d.fillOval(centerX - 2, centerY - 2, 4, 4);//		g2d.setColor(Color.black);//		//		produceSprial(maxAlpha+1,beta);//		g2d.setColor(Color.red);//		g2d.draw(generalPath);//		//		g2d.setColor(Color.pink);//		g2d.drawOval(//				(int) (centerX - biggestCircleRadicus), //				(int) (centerY - biggestCircleRadicus), //				(int) (2* biggestCircleRadicus), //				(int) (2*biggestCircleRadicus));//		g2d.setStroke(new BasicStroke(1.0f));//		produceSprial(80,beta);//		g2d.setColor(Color.red);//		g2d.draw(generalPath);//		//		produceSprial(15,beta);//		g2d.setColor(Color.blue);//		g2d.draw(generalPath);//		//		//		produceSprial(100,beta);//		g2d.setColor(Color.magenta);//		g2d.draw(generalPath);//		//		produceSprial(5,beta);//		g2d.setColor(Color.green);//		g2d.draw(generalPath);//		produceSprial(85,5);//		g2d.setColor(Color.blue);//		g2d.draw(generalPath);//		produceSprial(45,beta);//		g2d.setColor(Color.cyan);//		g2d.draw(generalPath);	}	/**	 * 同 RectPhyloLayout，因为它绘制在底部！	 * 	 * @param g2d	 */	protected void drawButtomAxis(Graphics2D g2d) {		if (!is4AnnotationDialog && treeLayoutProperties.isShowAxisBar()) {			double totalAvailableAlpha = maxAlpha - treeLayoutProperties.getRootTipLength();			double leftBlankLength = treeLayoutProperties.getRootTipLength();//			if (treeLayoutProperties.isShowOutgroup() && isForGlobalPhyoloTree) {//				leftBlankLength += TreeLayoutProperties.MAIN_VIRUS_ROOT_PERCENTIGE * totalAvailableAlpha;//			}			g2d.setColor(Color.decode("#E9E4E6"));			g2d.setFont(treeLayoutProperties.getAxisFont());			g2d.setStroke(new BasicStroke(1f));			List<java.lang.Double> displayeDoubles = buttomScaleBarDrawProperty.getDisplayeDoubles();			List<String> displayedStrings = buttomScaleBarDrawProperty.getDisplayedStrings();			int count = displayedStrings.size();			SprialLayoutProperty circularLayoutPropertiy = treeLayoutProperties.getSprialLayoutPropertiy();			int totolDeg = circularLayoutPropertiy.getGlobalExtendingDegree();			g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);			for (int i = 0; i < count; i++) {				java.lang.Double double1 = displayeDoubles.get(i);				int radicus = (int) (leftBlankLength + double1 * totalAvailableAlpha);				GeneralPath clone = produceSprial(0, totolDeg, radicus, beta);				g2d.draw(clone);				String str = displayedStrings.get(i);				Double tt = GuiCalculator.calculateSpiralLocation(radicus, beta, totolDeg, centerX, centerY);				float xStr = (float) (tt.x + 5);				float yStr = (float) (tt.y + 6);				g2d.drawString(str, xStr, yStr);			}		}	}		@Override	protected void leafLineDrawingProcess(Graphics2D g2d, GraphicsNode node) {		drawEachLine(g2d, node);			}		@Override	protected void rootDrawingProcess(Graphics2D g2d, GraphicsNode node) {		DrawUtil.drawRootTip(g2d, node, treeLayoutProperties);				g2d.setColor(Color.darkGray);				double x2 = node.getXSelf();		double y2 = node.getYSelf();				lineDrawUtil.setLine(centerX, centerY, x2, y2);				//g2d.setStroke(new BasicStroke(2f));		g2d.draw(lineDrawUtil);	}		@Override	protected void innerNodeDrawingProcess(Graphics2D g2d, GraphicsNode node) {		drawEachLine(g2d, node);	}	private void drawEachLine(Graphics2D g2d, GraphicsNode node) {		commonDrawEachUnit(g2d, node, true);		GraphicsNode parent = (GraphicsNode) node.getParent();		double radicus = parent.getRadicusIfNeeded();		double currentAngle = node.getAngleIfNeeded();		double parentAngle = parent.getAngleIfNeeded();		double min = Math.min(currentAngle, parentAngle);		double abs = Math.abs(currentAngle - parentAngle);		realConfigurate(radicus, min, abs,generalPath);		g2d.draw(generalPath);//		final int size = 2;//		Point2D.Double startPos = GuiCalculator.calculateSpiralLocation(radicus, beta, min, centerX,centerY);//		g2d.setColor(Color.magenta);//		g2d.fillOval((int) (startPos.x - size), (int) (startPos.y - size), 2 * size, 2 * size);//		g2d.drawString("start", (int) (startPos.x - size), (int) (startPos.y - size));//		g2d.setColor(Color.green);//		Point2D.Double endPos = GuiCalculator.calculateSpiralLocation(radicus, beta, min+abs, centerX,centerY);//		g2d.fillOval((int) (endPos.x - size), (int) (endPos.y - size), 2 * size, 2 * size);//		g2d.drawString("End", (int) (endPos.x - size), (int) (endPos.y - size));	}//	Point2D.Double startPos;//	Point2D.Double endPos;	@Override	protected GeneralPath configGneralPath(double radicus, double lowAngle, double extent) {		GeneralPath generalPath2 = new GeneralPath();		realConfigurate(radicus,lowAngle,extent,generalPath2);		return generalPath2;	}	private void realConfigurate(double radicus, double lowAngle, double extent, GeneralPath generalPath) {		final int numOfDivider = 100;		double eachDeg = extent / numOfDivider;		for (int i = 0; i < numOfDivider; i++) {			Double pos = GuiCalculator.calculateSpiralLocation(radicus, beta, lowAngle + eachDeg * i, centerX,					centerY);			if (i == 0) {				generalPath.reset();				generalPath.moveTo(pos.getX(), pos.getY());			} else {				generalPath.lineTo(pos.getX(), pos.getY());			}		}		Double pos = GuiCalculator.calculateSpiralLocation(radicus, beta, lowAngle + extent, centerX, centerY);		generalPath.lineTo(pos.getX(), pos.getY());//		startPos = GuiCalculator.calculateSpiralLocation(radicus, beta, lowAngle, centerX, centerY);//		endPos = GuiCalculator.calculateSpiralLocation(radicus, beta, lowAngle + extent, centerX, centerY);	}}