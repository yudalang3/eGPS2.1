package module.evolview.phylotree.visualization.layout;import java.awt.BasicStroke;import java.awt.Color;import java.awt.Graphics2D;import java.awt.RenderingHints;import java.awt.geom.GeneralPath;import java.awt.geom.Point2D.Double;import java.util.LinkedList;import java.util.List;import java.util.function.Function;import module.evolview.gfamily.work.gui.DrawUtil;import module.evolview.gfamily.work.gui.tree.PhylogeneticTreePanel;import module.evolview.gfamily.work.gui.tree.annotation.DrawPropInternalNode2LeafAnno;import module.evolview.gfamily.work.gui.tree.annotation.DrawPropInternalNodeInsituAnno;import module.evolview.gfamily.work.gui.tree.annotation.DrawPropOutterSidewardAnno;import module.evolview.gfamily.work.gui.tree.annotation.OutterSidewardLocation;import module.evolview.phylotree.visualization.graphics.struct.NodeType;import module.evolview.gfamily.work.model.tree.AnnotationsProperties;import module.evolview.gfamily.work.model.tree.AnnotationsProperties4LinageType;import module.evolview.gfamily.work.model.tree.GraphicsNode;import module.evolview.phylotree.visualization.graphics.struct.SprialLayoutProperty;import module.evolview.gfamily.work.model.tree.TreeLayoutProperties;import module.evolview.phylotree.visualization.graphics.struct.util.GraphicTreePropertyCalculator;import module.evolview.phylotree.visualization.graphics.struct.util.GraphicTreePropertyCalculator.LongestRoot2leafBean;import graphic.engine.guicalculator.GuiCalculator;import module.evolview.phylotree.visualization.graphics.struct.TreeDecideUtil;/** * 注意：RadicusIfNeeded这里不是一个真正的半径，而是介于minBeta与maxBeta之间的值 * */public class SpiralPhyloWithBeta extends SprialLayout {	protected double maxBeta;	private double minBeta;	/** 多出来的参数！ */	private double betaFactor = 2.5;	/** Global alpha */	private double alpha;		private GeneralPath generalPath = new GeneralPath(GeneralPath.WIND_EVEN_ODD, 1000);	public SpiralPhyloWithBeta(TreeLayoutProperties controller, GraphicsNode rootNode,			PhylogeneticTreePanel phylogeneticTreePanel) {		super(controller, rootNode, phylogeneticTreePanel);	}	@Override	protected void beforeCalculate(int width, int height) {		super.beforeCalculate(width, height);		SprialLayoutProperty circularLayoutPropertiy = treeLayoutProperties.getSprialLayoutPropertiy();		final int GAP_SIZE = circularLayoutPropertiy.getGapSize();		betaFactor = circularLayoutPropertiy.getBetaFactor();		alpha = treeLayoutProperties.getRootTipLength();		maxBeta = (biggestCircleRadicus - alpha) / Math.toRadians(circularLayoutPropertiy.getGlobalExtendingDegree());		minBeta = (2 * maxBeta * Math.PI + GAP_SIZE) / (4 * Math.PI);		LongestRoot2leafBean maxLengthOfRoot2LeafNoOutgroup = GraphicTreePropertyCalculator				.getMaxLengthOfRoot2Leaf(rootNode);		double maxLengthOfRoot2Leaf = maxLengthOfRoot2LeafNoOutgroup.getLength();		canvas2logicRatio = (maxBeta - minBeta) / maxLengthOfRoot2Leaf;		configurateButtomScaleBarDrawProperty(maxLengthOfRoot2LeafNoOutgroup.getLength(),				maxLengthOfRoot2LeafNoOutgroup.getLeaf());	}	@Override	public void calculateForPainting(int width, int height) {		beforeCalculate(width, height);		GraphicsNode node = rootNode;		recursiveCalculate(node, 0);		// set root properties!		node.setXParent(centerX);		node.setYParent(centerY);		Double tt = GuiCalculator.calculateSpiralLocation(alpha, betaFactor * node.getRadicusIfNeeded(),				node.getAngleIfNeeded(), centerX, centerY);		node.setXSelf(tt.x);		node.setYSelf(tt.y);		// 不用加了 这个时候外群已经看不出来了！//		if (treeLayoutProperties.isShowOutgroup()) {//			GraphicsNode outgroupNode = TreePropertyCalculator.getOutgroupNode(node);//			//			double angleIfNeeded = outgroupNode.getAngleIfNeeded();//			double delayStartDegree = 0;//			SprialLayoutProperty circularLayoutPropertiy = treeLayoutProperties.getSprialLayoutPropertiy();//			int totolDeg = circularLayoutPropertiy.getGlobalExtendingDegree();//			//			if (angleIfNeeded == globalStartDegree) {//				delayStartDegree = globalStartDegree - 15;//			}else {//				delayStartDegree = globalStartDegree + totolDeg +15;//			}//			//			//			tt = GuiCalculator.calculateSpiralLocation(alpha, betaFactor * node.getRadicusIfNeeded(),//					node.getAngleIfNeeded(), centerX, centerY);//			tt = GuiCalculator.calculateSpiralLocation(node.getRadicusIfNeeded(), beta, delayStartDegree,//					centerX, centerY);//			outgroupNode.setXParent(tt.x);//			outgroupNode.setYParent(tt.y);//			//			tt = GuiCalculator.calculateSpiralLocation(100, beta, delayStartDegree,//					centerX, centerY);//			//			outgroupNode.setXSelf(tt.x);//			outgroupNode.setYSelf(tt.y);//			//			//		}		scaleBarProperty.setIfDrawScaleBar(true);		afterCalculation();	}	@Override	protected void configurateMainAnnotation(AnnotationsProperties annotationsProperties) {		List<DrawPropInternalNode2LeafAnno> internalNode2LeafAnnos = annotationsProperties.getInternalNode2LeafAnnos();		for (DrawPropInternalNode2LeafAnno tt : internalNode2LeafAnnos) {			if (tt.shouldConfigurateAndPaint()) {				GraphicsNode currentGraphicsNode = tt.getCurrentGraphicsNode();				List<GraphicsNode> leaves = GraphicTreePropertyCalculator.getLeaves(currentGraphicsNode);				GraphicsNode firstLeaf = leaves.get(0);				GraphicsNode lastLeaf = leaves.get(leaves.size() - 1);				double startDeg = firstLeaf.getAngleIfNeeded();				double lastDeg = lastLeaf.getAngleIfNeeded();				GeneralPath clone = produceSprialRing(startDeg, lastDeg - startDeg, alpha,						betaFactor * currentGraphicsNode.getRadicusIfNeeded(), alpha, maxBeta);				tt.setDrawShape(clone);			}		}		// 这个注释要特殊处理		// List<DrawPropLeafNameAnno> leafNameAnnos =		// annotationsProperties.getLeafNameAnnos();		annotationsProperties.configurateLeafNamesAnnotaion(false);		List<DrawPropOutterSidewardAnno> outterSidewardAnnos = annotationsProperties.getOutterSidewardAnnos();		for (DrawPropOutterSidewardAnno tt : outterSidewardAnnos) {			if (tt.shouldConfigurateAndPaint()) {				GraphicsNode currentGraphicsNode = tt.getCurrentGraphicsNode();				List<GraphicsNode> leaves = GraphicTreePropertyCalculator.getLeaves(currentGraphicsNode);				GraphicsNode firstLeaf = leaves.get(0);				GraphicsNode lastLeaf = leaves.get(leaves.size() - 1);				double startDeg = firstLeaf.getAngleIfNeeded();				double lastDeg = lastLeaf.getAngleIfNeeded();				GeneralPath clone = produceSprial(startDeg, lastDeg - startDeg, alpha + 2, maxBeta);				Double point = GuiCalculator.calculateSpiralLocation(alpha, maxBeta, 0.5 * (startDeg + lastDeg),						centerX, centerY);				tt.setTextLocationAndShape(point.getX(), point.getY(), clone);			}		}		List<DrawPropInternalNodeInsituAnno> internalNode2LeafInsituAnnos = annotationsProperties				.getInternalNode2LeafInsituAnnos();		for (DrawPropInternalNodeInsituAnno tt : internalNode2LeafInsituAnnos) {			if (tt.shouldConfigurateAndPaint()) {				tt.configurate();			}		}	}	@Override	protected void configurateLinageTypeAnnotation(AnnotationsProperties4LinageType annotationsProperties) {		linageTypeSidewardAnnotationCalculator = new Function<LinkedList<GraphicsNode>, OutterSidewardLocation>() {			@Override			public OutterSidewardLocation apply(LinkedList<GraphicsNode> t) {				GraphicsNode firstLeaf = t.getFirst();				GraphicsNode lastLeaf = t.getLast();				double startDeg = firstLeaf.getAngleIfNeeded();				double endDeg = lastLeaf.getAngleIfNeeded();				double extentDeg = endDeg - startDeg;				if (extentDeg < 1) {					extentDeg = 1;				}				GeneralPath clone = produceSprial(startDeg, extentDeg, alpha + 2, maxBeta);				Double point = GuiCalculator.calculateSpiralLocation(alpha, maxBeta, 0.5 * (startDeg + endDeg), centerX,						centerY);				OutterSidewardLocation ret = new OutterSidewardLocation();				ret.setShape(clone);				ret.setTextX((float) point.getX());				ret.setTextY((float) point.getY());				return ret;			}		};		linageTypeNode2LeafAnnotationCalculator = new Function<LinkedList<GraphicsNode>, OutterSidewardLocation>() {			@Override			public OutterSidewardLocation apply(LinkedList<GraphicsNode> t) {				GraphicsNode firstLeaf = t.getFirst();				GraphicsNode lastLeaf = t.getLast();				GraphicsNode mrca = GraphicTreePropertyCalculator.getMostRecentCommonAnsester(firstLeaf, lastLeaf);				double startDeg = firstLeaf.getAngleIfNeeded();				double lastDeg = lastLeaf.getAngleIfNeeded();				double extendDeg = lastDeg - startDeg;				if (extendDeg < 1) {					extendDeg = 1;					startDeg -= 0.5;					lastDeg = startDeg + 1;				}				GeneralPath clone = produceSprialRing(startDeg, extendDeg, alpha,						betaFactor * mrca.getRadicusIfNeeded(), alpha, maxBeta);				Double point = GuiCalculator.calculateSpiralLocation(alpha, maxBeta, 0.5 * (startDeg + lastDeg),						centerX, centerY);				OutterSidewardLocation ret = new OutterSidewardLocation();				ret.setShape(clone);				ret.setTextX((float) point.getX());				ret.setTextY((float) point.getY());				return ret;			}		};		super.configurateLinageTypeAnnotation(annotationsProperties);	}	private void recursiveCalculate(GraphicsNode node, double cumulateBranchLengthExceptCurrent) {		double branchLen = cumulateBranchLengthExceptCurrent + node.getDisplayedBranchLength();		double realBranchLenAlsoBeta = minBeta + branchLen * canvas2logicRatio;		NodeType nodeType = TreeDecideUtil.decideNodeType(node, rootNode);		switch (nodeType) {		case LEAF:			node.setAngleIfNeeded(leafLoop * increseDeg);			node.setRadicusIfNeeded(realBranchLenAlsoBeta);			assignLocation(node);			leafLoop++;			break;		default:			// 这一行要比递归调用早！			node.setRadicusIfNeeded(realBranchLenAlsoBeta);			// internal first recursive			for (int i = 0; i < node.getChildCount(); i++) {				recursiveCalculate((GraphicsNode) node.getChildAt(i), branchLen);			}			// 这一行要比递归调用晚！			double angle = averageValueOfAngleFromChildren(node);			node.setAngleIfNeeded(angle);			if (nodeType != NodeType.ROOT) {				assignLocation(node);			}			break;		}	}	/**	 * 对于当前的node来说: angle和radicus是这个循环赋值的！	 */	protected void assignLocation(GraphicsNode node) {		double currentNodeAngle = node.getAngleIfNeeded();		Double tt = GuiCalculator.calculateSpiralLocation(alpha, betaFactor * node.getRadicusIfNeeded(),				currentNodeAngle, centerX, centerY);		node.setXSelf(tt.x);		node.setYSelf(tt.y);		// System.out.println("Current node angle: "+currentNodeAngle+"\tNode radicus:		// "+node.getRadicusIfNeeded()+" Point: "+tt.x+" "+tt.y);		GraphicsNode parent = (GraphicsNode) node.getParent();		tt = GuiCalculator.calculateSpiralLocation(alpha, betaFactor * parent.getRadicusIfNeeded(), currentNodeAngle,				centerX, centerY);		node.setXParent(tt.x);		node.setYParent(tt.y);		// System.out.println("Parent radicus: "+parent.getRadicusIfNeeded()+" Point:		// "+tt.x+" "+tt.y);		// System.out.println(parent.getRadicusIfNeeded()+"		// "+node.getRadicusIfNeeded()+"		// ------------------------------------------------");	}	@Override	protected void specificTreeDrawingProcess(Graphics2D g2d) {//		double rootTipLength = treeLayoutProperties.getRootTipLength();		// Draw rings//		SprialLayoutProperty circularLayoutPropertiy = treeLayoutProperties.getSprialLayoutPropertiy();//		double totolDeg = circularLayoutPropertiy.getGlobalExtendingDegree();//		produceSprialRing(0, totolDeg, rootTipLength, minBeta, rootTipLength, maxBeta);//		g2d.setColor(Color.lightGray);//		g2d.draw(generalPath);//		g2d.setColor(new Color(12, 12, 5, 12));//		g2d.fill(generalPath);//		produceSprial(rootTipLength, minBeta * betaFactor);//		g2d.setColor(Color.red);//		g2d.draw(generalPath);////		produceSprial(rootTipLength, 21);//		g2d.setColor(Color.magenta);//		g2d.draw(generalPath);////		produceSprial(rootTipLength, 22);//		g2d.setColor(Color.green);//		g2d.draw(generalPath);////		produceSprial(rootTipLength, 33);//		g2d.setColor(Color.cyan);//		g2d.draw(generalPath);//		produceSprial(rootTipLength, 25);//		g2d.setColor(Color.black);//		g2d.draw(generalPath);		drawButtomAxis(g2d);	}	/**	 * 同 RectPhyloLayout，因为它绘制在底部！	 * 	 * @param g2d	 */	protected void drawButtomAxis(Graphics2D g2d) {		if (!is4AnnotationDialog && treeLayoutProperties.isShowAxisBar()) {			g2d.setFont(treeLayoutProperties.getAxisFont());			double totalAvailableAlpha = maxBeta - minBeta;			double leftBlankLength = minBeta;//			if (treeLayoutProperties.isShowOutgroup() && isForGlobalPhyoloTree) {//				leftBlankLength += TreeLayoutProperties.MAIN_VIRUS_ROOT_PERCENTIGE * totalAvailableAlpha;//			}			g2d.setColor(Color.decode("#E9E4E6"));			g2d.setStroke(new BasicStroke(1f));			List<java.lang.Double> displayeDoubles = buttomScaleBarDrawProperty.getDisplayeDoubles();			List<String> displayedStrings = buttomScaleBarDrawProperty.getDisplayedStrings();			int count = displayedStrings.size();			SprialLayoutProperty circularLayoutPropertiy = treeLayoutProperties.getSprialLayoutPropertiy();			int totolDeg = circularLayoutPropertiy.getGlobalExtendingDegree();			g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);			for (int i = 0; i < count; i++) {				java.lang.Double double1 = displayeDoubles.get(i);				double beta = leftBlankLength + double1 * totalAvailableAlpha;				GeneralPath clone = produceSprial(0, totolDeg, alpha, betaFactor * beta);				g2d.draw(clone);				String str = displayedStrings.get(i);				Double tt = GuiCalculator.calculateSpiralLocation(alpha, beta, totolDeg, centerX, centerY);				float xStr = (float) (tt.x + 5);				float yStr = (float) (tt.y);				g2d.drawString(str, xStr, yStr);			}		}	}		@Override	protected void leafLineDrawingProcess(Graphics2D g2d, GraphicsNode node) {		drawEachLine(g2d, node);			}		@Override	protected void rootDrawingProcess(Graphics2D g2d, GraphicsNode node) {		DrawUtil.drawRootTip(g2d, node, treeLayoutProperties);	}		@Override	protected void innerNodeDrawingProcess(Graphics2D g2d, GraphicsNode node) {		drawEachLine(g2d, node);	}	private void drawEachLine(Graphics2D g2d, GraphicsNode node) {		commonDrawEachUnit(g2d, node, true);		GraphicsNode parent = (GraphicsNode) node.getParent();		double radicus = parent.getRadicusIfNeeded();		double currentAngle = node.getAngleIfNeeded();		double parentAngle = parent.getAngleIfNeeded();		realConfigurate(radicus, Math.min(currentAngle, parentAngle), Math.abs(currentAngle - parentAngle),generalPath);		g2d.draw(generalPath);	}	@Override	protected GeneralPath configGneralPath(double radicus, double lowAngle, double extent) {		GeneralPath generalPath2 = new GeneralPath();		realConfigurate(radicus,lowAngle,extent,generalPath2);		return generalPath2;	}		private void realConfigurate(double radicus, double lowAngle, double extent, GeneralPath generalPath) {		final int numOfDivider = 100;		double eachDeg = extent / numOfDivider;		for (int i = 0; i < numOfDivider; i++) {			Double pos = GuiCalculator.calculateSpiralLocation(alpha, betaFactor * radicus,					lowAngle + eachDeg * i, centerX, centerY);			if (i == 0) {				generalPath.reset();				generalPath.moveTo(pos.getX(), pos.getY());			} else {				generalPath.lineTo(pos.getX(), pos.getY());			}		}		Double pos = GuiCalculator.calculateSpiralLocation(alpha, betaFactor * radicus, lowAngle + extent,				centerX, centerY);		generalPath.lineTo(pos.getX(), pos.getY());	}}