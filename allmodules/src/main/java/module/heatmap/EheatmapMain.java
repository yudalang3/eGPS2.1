package module.heatmap;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.KeyListener;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.List;
import java.util.Map;

import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.SwingUtilities;

import org.jdesktop.swingx.JXTaskPane;
import org.jdesktop.swingx.JXTaskPaneContainer;

import com.jidesoft.swing.JideSplitPane;

import egps2.utils.common.model.datatransfer.ThreeTuple;
import egps2.utils.common.model.datatransfer.TwoTuple;
import egps2.EGPSProperties;
import utils.storage.MapPersistence;
import egps2.UnifiedAccessPoint;
import egps2.frame.ModuleFace;
import module.heatmap.eheatmap.AbstrctEHeatmapPaintPanel;
import module.heatmap.eheatmap.HeatmapController;
import module.heatmap.eheatmap.cirpainter.CircularPaintingPanel;
import module.heatmap.eheatmap.enums.PaintingLayout;
import module.heatmap.eheatmap.gui.LeftCellProperties;
import module.heatmap.eheatmap.gui.LeftConveOperationPanel;
import module.heatmap.eheatmap.gui.LeftDataTransformationPanel;
import module.heatmap.eheatmap.gui.LeftDisplayPanel0320;
import module.heatmap.eheatmap.gui.LeftHierarchicalClusteringPanel0319;
import module.heatmap.eheatmap.gui.LeftKMeansClusteringPanel;
import module.heatmap.eheatmap.gui.LeftLayoutPanel0310;
import module.heatmap.eheatmap.gui.QuikylyDebugPanel;
import module.heatmap.eheatmap.listener.MouseAndKeyListener;
import module.heatmap.eheatmap.listener.MouseWheelListener;
import module.heatmap.eheatmap.model.DataModel;
import module.heatmap.eheatmap.model.ParameterModel;
import module.heatmap.eheatmap.rectpainter.RectPaintingPanel;
import module.heatmap.eheatmap.util.IncorporateParasInfo;
import egps2.modulei.IInformation;
import egps2.modulei.IModuleLoader;
import egps2.panels.reusablecom.ParameterInitialized;

@SuppressWarnings("serial")
public class EheatmapMain extends ModuleFace implements IInformation {
	private final HeatmapController controller;
	private DataModel dataModel;
	private AbstrctEHeatmapPaintPanel paintPanel;
	private ParameterModel paraModel = new ParameterModel();

	private IncorporateParasInfo incorporateParasInfo = new IncorporateParasInfo();
	private int INDEX_CONVENIENT_TASKPANEL = 0;
	private int INDEX_COLORSCHEME_TASKPANEL = 1;
	private int INDEX_DATATRANSFORM_TASKPANEL = 2;
	private int INDEX_HIERARCLUSTERING_TASKPANEL = 3;
	private int INDEX_KMEANSCLUSTERING_TASKPANEL = 4;
	private int INDEX_DISPLAY_TASKPANEL = 5;
	private int INDEX_LAYOUT_TASKPANEL = 6;

	private ParameterInitialized[] paraPanels = new ParameterInitialized[7];

	public final Font defaultFont = UnifiedAccessPoint.getLaunchProperty().getDefaultFont();
	public final Font titleFont = UnifiedAccessPoint.getLaunchProperty().getDefaultTitleFont();

	private JScrollPane scrollPane;

	private TwoTuple<ParameterModel, DataModel> twoTuple;
	private JXTaskPaneContainer taskPaneContainer;

	String[] FEATURES = new String[] { "Import from data structure", 
			"Import from file contens", //1
			"Different color scheme", //2
			"Various cell shape", //3
			"Circular layout", //4
			"Data transformation",//5
			"Hierarchical clustering",//6
			"K-Means++ clustering",//7
			"Display cell values",//8
	};

	// support for information
	private String howModuleLaunched = "Module launched by click the open button.";
	private String whatDataInvoked = "The data is loading from the eGPS VOICM import dialog.";
	private String summaryOfResults = "The heatmap with rectangular layout is generated by the eGPS software.";

	VOICM4Eheatmap voicmHeatmapEGPS2 = new VOICM4Eheatmap(this);
	/**
	 * 为了持久化保存
	 */
	private Map<String, Integer> str2numberMap;
	private JSplitPane mainSplitPane;
	private final String dividerKey = "mtv.divider.location";
	private LeftDataTransformationPanel leftDataTransFormationPanel;

	EheatmapMain(IModuleLoader moduleLoader) {
		super(moduleLoader);

		controller = new HeatmapController(this);
		setLayout(new BorderLayout());
		add(getMainSplitPane(), BorderLayout.CENTER);
	}

	/**
	 * 感觉有一个隐患，没错都调用这个方法不就造成一直在初始化吗？
	 */
	private void initializeListeners() {

		java.awt.event.MouseWheelListener[] mouseWheelListeners = paintPanel.getMouseWheelListeners();
		for (java.awt.event.MouseWheelListener mouseWheelListener : mouseWheelListeners) {
			paintPanel.removeMouseWheelListener(mouseWheelListener);
		}
		MouseListener[] mouseListeners = paintPanel.getMouseListeners();
		for (MouseListener mouseWheelListener : mouseListeners) {
			paintPanel.removeMouseListener(mouseWheelListener);
		}
		MouseMotionListener[] mouseMotionListeners = paintPanel.getMouseMotionListeners();
		for (MouseMotionListener mouseWheelListener : mouseMotionListeners) {
			paintPanel.removeMouseMotionListener(mouseWheelListener);
		}
		KeyListener[] keyListeners = paintPanel.getKeyListeners();
		for (KeyListener mouseWheelListener : keyListeners) {
			paintPanel.removeKeyListener(mouseWheelListener);
		}

		////////////////////////////////////////////////////////

		MouseWheelListener mouseWheelListener = new MouseWheelListener(paintPanel, controller);
		paintPanel.addMouseWheelListener(mouseWheelListener);

		MouseAndKeyListener Listener = new MouseAndKeyListener(controller, paintPanel);
		paintPanel.addMouseListener(Listener);
		paintPanel.addMouseMotionListener(Listener);
		paintPanel.addKeyListener(Listener);
	}

	/**
	 * For debug
	 */
	public void quicklyResetData(int index) {
		switch (index) {
		case 0:
			paraModel.setIfPaintRowTree(false);
			paraModel.setIfPaintColTree(false);
			paraModel.setIfPaintRowNames(false);
			paraModel.setIfPaintColNames(false);
			paraModel.setIfPaintMapLegend(false);
			paraModel.setIfPaintAnnotationLegend(false);
			break;
		case 1:
			paraModel.setIfPaintRowTree(true);
			paraModel.setIfPaintColTree(false);
			paraModel.setIfPaintRowNames(false);
			paraModel.setIfPaintColNames(false);
			paraModel.setIfPaintMapLegend(false);
			paraModel.setIfPaintAnnotationLegend(false);
			break;
		case 2:
			paraModel.setIfPaintRowTree(true);
			paraModel.setIfPaintColTree(true);
			paraModel.setIfPaintRowNames(false);
			paraModel.setIfPaintColNames(false);
			paraModel.setIfPaintMapLegend(false);
			paraModel.setIfPaintAnnotationLegend(false);
			break;
		case 3:
			paraModel.setIfPaintRowTree(true);
			paraModel.setIfPaintColTree(false);
			paraModel.setIfPaintRowNames(true);
			paraModel.setIfPaintColNames(true);
			paraModel.setIfPaintMapLegend(false);
			paraModel.setIfPaintAnnotationLegend(false);
			break;
		case 4:
			paraModel.setIfPaintRowTree(true);
			paraModel.setIfPaintColTree(true);
			paraModel.setIfPaintRowNames(true);
			paraModel.setIfPaintColNames(true);
			paraModel.setIfPaintMapLegend(false);
			paraModel.setIfPaintAnnotationLegend(false);
			break;
		case 5:
			paraModel.setIfPaintRowTree(true);
			paraModel.setIfPaintColTree(true);
			paraModel.setIfPaintRowNames(true);
			paraModel.setIfPaintColNames(true);
			paraModel.setIfPaintMapLegend(true);
			paraModel.setIfPaintAnnotationLegend(false);
			break;
		case 6:
			paraModel.setIfPaintRowTree(true);
			paraModel.setIfPaintColTree(true);
			paraModel.setIfPaintRowNames(true);
			paraModel.setIfPaintColNames(true);
			paraModel.setIfPaintMapLegend(true);
			paraModel.setIfPaintAnnotationLegend(true);
			break;
		default:
			// Nothing to do here!
			break;
		}
		controller.strongestRefreshHeatmapAndRecoverDim();
	}

	/**
	 * first is row names; next is col names; last is data matrix!
	 * 
	 * @param element
	 */
	public void setDataModel4MatrixAndInitialize(ThreeTuple<String[], String[], double[][]> element) {
		dataModel = new DataModel();
		dataModel.setDataFromMatrixWithNames(element);

		paraModel = new ParameterModel();
		if (dataModel.getColNames().length > 1500) {
			paraModel.setIfPaintColNames(false);
			paraModel.setIfShowBorder(false);
		}
		if (dataModel.getRowNames().length > 1500) {
			paraModel.setIfPaintRowNames(false);
			paraModel.setIfShowBorder(false);
		}

		paintPanel.setDataModel(dataModel);
		paintPanel.setParaModel(paraModel);
		controller.setDataModel(dataModel);
		controller.setParaModel(paraModel);
		controller.strongestRefreshHeatmapAndRecoverDim();

		initializeListeners();

		reInitializeLeftAllTaskPanes();
	}

	public void setDataModel4FileContents(List<String> inputContents) {
		dataModel = new DataModel();
		paraModel = new ParameterModel();

		dataModel.setDataFromTextContens(inputContents, true);

		if (dataModel.getColNames().length > 1500) {
			paraModel.setIfPaintColNames(false);
			paraModel.setIfShowBorder(false);
		}
		if (dataModel.getRowNames().length > 1500) {
			paraModel.setIfPaintRowNames(false);
			paraModel.setIfShowBorder(false);
		}

		incorporateParameterInformation(inputContents);
		paintPanel.setDataModel(dataModel);
		paintPanel.setParaModel(paraModel);
		controller.setDataModel(dataModel);
		controller.setParaModel(paraModel);
		controller.strongestRefreshHeatmapAndRecoverDim();

		initializeListeners();
		reInitializeLeftAllTaskPanes();
	}

	public void reInitializeLeftLayoutPanelLayout() {
		paraPanels[INDEX_LAYOUT_TASKPANEL].initializeParameters();
	}

	public void reInitializeLeftAllTaskPanes() {
		for (ParameterInitialized parameterInitialized : paraPanels) {
			parameterInitialized.initializeParameters();
		}
	}

	private void incorporateParameterInformation(List<String> inputContents) {
		incorporateParasInfo.readAndAssign(paraModel, dataModel, inputContents);
	}

	/**
	 * 
	 * @param options: boolean[2] the first index is whether cluster rows, second is
	 *                 cols
	 */
	public void quicklyResetData(boolean[] options) {
		paraModel = new ParameterModel();
		final boolean whetherClusterRows = options[0];
		final boolean whetherClusterCols = options[1];

		paraModel.setIfPaintRowTree(whetherClusterRows);
		paraModel.setIfPaintColTree(whetherClusterCols);

		controller.strongestRefreshHeatmapAndRecoverDim();
	}

	private JSplitPane getMainSplitPane() {
		mainSplitPane = new JSplitPane(JideSplitPane.HORIZONTAL_SPLIT);

		mainSplitPane.setDividerSize(7);

		Map<String, Integer> str2numberMap2 = getStr2numberMap();
		Integer dividerLocation = str2numberMap2.get(dividerKey);
		if (dividerLocation == null) {
			dividerLocation = 330;
		}
		mainSplitPane.setDividerLocation(dividerLocation);
		mainSplitPane.add(getLeftToolPane());

		scrollPane = new JScrollPane();
		initializePintingPanel(PaintingLayout.Rectangular);
		scrollPane.getHorizontalScrollBar().addAdjustmentListener(e -> {
			refresh();
		});
		scrollPane.getVerticalScrollBar().addAdjustmentListener(e -> {
			refresh();
		});

		scrollPane.setBackground(Color.white);

		mainSplitPane.add(scrollPane);
		mainSplitPane.setOneTouchExpandable(true);
		mainSplitPane.setBorder(null);
		return mainSplitPane;
	}

	/**
	 * 这个方法会更新全局的 scrollPanel
	 * 
	 * @param layoutType
	 * @return
	 */
	public void initializePintingPanel(PaintingLayout layoutType) {

		if (layoutType == PaintingLayout.Rectangular) {
			paintPanel = new RectPaintingPanel();
			paintPanel.setDataModel(dataModel);
			paintPanel.setParaModel(paraModel);
			
			summaryOfResults = "The heatmap with rectangular layout is generated by the eGPS software.";
		} else {
			paintPanel = new CircularPaintingPanel(paraModel);
			paintPanel.setDataModel(dataModel);
			summaryOfResults = "The heatmap with circular layout is generated by the eGPS software.";
		}

		controller.setPaintJPanel(paintPanel);
		paintPanel.setController(controller);
		scrollPane.setViewportView(paintPanel);

		if (dataModel == null) {
			// 这说明是第一次
		} else {
			controller.strongestRefreshHeatmap(controller.getPaintPanelHeight(), controller.getPaintPanelWidth());
			initializeListeners();
			reInitializeLeftAllTaskPanes();
		}
	}

	public void refresh() {
		scrollPane.updateUI();
	}

	public JScrollPane getPaintingScrollPane() {
		return scrollPane;
	}

	private JPanel getLeftToolPane() {
		JPanel jPanel = new JPanel(new BorderLayout());
		taskPaneContainer = new JXTaskPaneContainer();

		taskPaneContainer.setBackground(Color.WHITE);
		taskPaneContainer.setBackgroundPainter(null);

		addJXTaskPanels(taskPaneContainer);

		jPanel.setMinimumSize(new Dimension(290, 200));
		// a scrollPane is needed to handle situation when JXTaskPanes extend original
		// area!
		jPanel.add(new JScrollPane(taskPaneContainer), BorderLayout.CENTER);

		return jPanel;
	}

	// ====================为了持久化保存
	private String getStorePath() {
		String storePath = EGPSProperties.JSON_DIR.concat("/egps.eheatmap.saveData.gz");
		return storePath;
	}

	private Map<String, Integer> getStr2numberMap() {
		if (str2numberMap == null) {
			String storePath = getStorePath();
			str2numberMap = MapPersistence.getStr2numberMap(storePath);
		}
		return str2numberMap;
	}

	/**
	 * 
	 * @param key
	 * @return 是否要折叠面板，true的话是true
	 */
	private boolean getValueOfStr4storage(String key) {
		Map<String, Integer> str2numberMap2 = getStr2numberMap();
		Integer dividerLocation = str2numberMap2.get(key);
		if (dividerLocation == null) {
			//
			dividerLocation = 1;
		}
		return dividerLocation.intValue() > 0;
	}
	// ====================为了持久化保存

	@Override
	public boolean closeTab() {
		super.closeTab();
		Component[] components = taskPaneContainer.getComponents();

		Map<String, Integer> str2numberMap = getStr2numberMap();

		for (Component component : components) {
			if (component instanceof JXTaskPane) {
				JXTaskPane jxTaskPane = (JXTaskPane) component;
				Integer saveNumber = jxTaskPane.isCollapsed() ? 1 : 0;
				str2numberMap.put(jxTaskPane.getTitle(), saveNumber);
			}
		}

		str2numberMap.put(dividerKey, mainSplitPane.getDividerLocation());
		MapPersistence.storeStr2numberMap(str2numberMap, getStorePath());

		return false;
	}

	/**
	 * The order is fixed: corresponding to what you see！！
	 * 
	 * @param taskPaneContainer
	 */
	private void addJXTaskPanels(JXTaskPaneContainer taskPaneContainer) {

		INDEX_CONVENIENT_TASKPANEL = 0;
		INDEX_COLORSCHEME_TASKPANEL = 1;
		INDEX_LAYOUT_TASKPANEL = 2;
		INDEX_DATATRANSFORM_TASKPANEL = 3;
		INDEX_HIERARCLUSTERING_TASKPANEL = 4;
		INDEX_KMEANSCLUSTERING_TASKPANEL = 5;
		INDEX_DISPLAY_TASKPANEL = 6;
		paraPanels = new ParameterInitialized[7];

		taskPaneContainer.add(getConvenietOperationTaskPanel());
		taskPaneContainer.add(getColorSchemeTaskPanel());
		taskPaneContainer.add(getLayoutTaskPanel());
		// taskPaneContainer.add(getDebugTaskPanel());
		taskPaneContainer.add(getDataTransformTaskPanel());
		taskPaneContainer.add(getHierarchicalClusteringTaskPanel());
		taskPaneContainer.add(getKMeansClusteringTaskPanel());
		taskPaneContainer.add(getDisplayTaskPanel());
	}

	private JXTaskPane getLayoutTaskPanel() {
		JXTaskPane operationPane = new JXTaskPane();
		String title = "Layout Options";
		boolean valueOfStr4storage = getValueOfStr4storage(title);
		operationPane.setCollapsed(valueOfStr4storage);
		operationPane.setFont(titleFont);
		operationPane.setTitle(title);

		LeftLayoutPanel0310 clusteringOptionsPanel = new LeftLayoutPanel0310(this);
		operationPane.add(new JScrollPane(clusteringOptionsPanel));
		paraPanels[INDEX_LAYOUT_TASKPANEL] = clusteringOptionsPanel;
		return operationPane;
	}

	private JXTaskPane getDisplayTaskPanel() {
		JXTaskPane operationPane = new JXTaskPane();
		String title = "Display Options";
		boolean valueOfStr4storage = getValueOfStr4storage(title);
		operationPane.setCollapsed(valueOfStr4storage);
		operationPane.setFont(titleFont);
		operationPane.setTitle(title);
		LeftDisplayPanel0320 clusteringOptionsPanel = new LeftDisplayPanel0320(this);
		operationPane.add(new JScrollPane(clusteringOptionsPanel));
		paraPanels[INDEX_DISPLAY_TASKPANEL] = clusteringOptionsPanel;

		return operationPane;
	}

	private JXTaskPane getColorSchemeTaskPanel() {
		JXTaskPane operationPane = new JXTaskPane();

		String title = "Cell Properties";
		boolean valueOfStr4storage = getValueOfStr4storage(title);
		operationPane.setCollapsed(valueOfStr4storage);

		operationPane.setFont(titleFont);
		operationPane.setTitle(title);
		LeftCellProperties clusteringOptionsPanel = new LeftCellProperties(this);
		operationPane.add(new JScrollPane(clusteringOptionsPanel));
		paraPanels[INDEX_COLORSCHEME_TASKPANEL] = clusteringOptionsPanel;

		return operationPane;
	}

	private JXTaskPane getHierarchicalClusteringTaskPanel() {
		JXTaskPane hierarchicalCluTaskPane = new JXTaskPane();

		String title = "Hierarchical Clustering";
		boolean valueOfStr4storage = getValueOfStr4storage(title);
		hierarchicalCluTaskPane.setCollapsed(valueOfStr4storage);

		hierarchicalCluTaskPane.setFont(titleFont);
		hierarchicalCluTaskPane.setTitle(title);

		LeftHierarchicalClusteringPanel0319 clusteringOptionsPanel = new LeftHierarchicalClusteringPanel0319(this);
		paraPanels[INDEX_HIERARCLUSTERING_TASKPANEL] = clusteringOptionsPanel;
		hierarchicalCluTaskPane.add(clusteringOptionsPanel);

		return hierarchicalCluTaskPane;
	}

	private JXTaskPane getKMeansClusteringTaskPanel() {
		JXTaskPane operationPane = new JXTaskPane();

		String title = "K-Means++ Clustering";
		boolean valueOfStr4storage = getValueOfStr4storage(title);
		operationPane.setCollapsed(valueOfStr4storage);

		operationPane.setFont(titleFont);
		operationPane.setTitle(title);
		LeftKMeansClusteringPanel clusteringOptionsPanel = new LeftKMeansClusteringPanel(this);
		paraPanels[INDEX_KMEANSCLUSTERING_TASKPANEL] = clusteringOptionsPanel;
		operationPane.add(clusteringOptionsPanel);

		return operationPane;
	}

	private JXTaskPane getDataTransformTaskPanel() {
		JXTaskPane operationPane = new JXTaskPane();

		String title = "Data Transformation";
		boolean valueOfStr4storage = getValueOfStr4storage(title);
		operationPane.setCollapsed(valueOfStr4storage);

		operationPane.setCollapsed(valueOfStr4storage);
		operationPane.setFont(titleFont);
		operationPane.setTitle(title);
		leftDataTransFormationPanel = new LeftDataTransformationPanel(this);
		paraPanels[INDEX_DATATRANSFORM_TASKPANEL] = leftDataTransFormationPanel;
		operationPane.add(leftDataTransFormationPanel);

		return operationPane;
	}

	private JXTaskPane getConvenietOperationTaskPanel() {
		JXTaskPane operationPane = new JXTaskPane();

		String title = "Convenient Operation";
		boolean valueOfStr4storage = getValueOfStr4storage(title);
		operationPane.setCollapsed(valueOfStr4storage);

		operationPane.setFont(titleFont);
		operationPane.setTitle(title);
		LeftConveOperationPanel operationPanel = new LeftConveOperationPanel(this);
		paraPanels[INDEX_CONVENIENT_TASKPANEL] = operationPanel;
		// operationPanel.setPreferredSize(new Dimension(200, 40));
		operationPane.add(operationPanel);

		return operationPane;
	}

	private JXTaskPane getDebugTaskPanel() {
		JXTaskPane displayJXTaskPane = new JXTaskPane();
		displayJXTaskPane.setTitle("Quick guiles");
		displayJXTaskPane.setFont(titleFont);

		JPanel layoutJPane = new QuikylyDebugPanel(this);
		displayJXTaskPane.add(layoutJPane);
		return displayJXTaskPane;
	}

	public HeatmapController getController() {
		return controller;
	}

	public void saveCurrentParaModelAndDataModel() {
		try {
			twoTuple = new TwoTuple<ParameterModel, DataModel>(paraModel.clone(), dataModel.clone());
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
	}

	public void recoverParaModelAndDataModel() {
		try {
			dataModel = twoTuple.second.clone();
			paraModel = twoTuple.first.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
		paintPanel.setDataModel(dataModel);
		paintPanel.setParaModel(paraModel);
		controller.setDataModel(dataModel);
		controller.setParaModel(paraModel);
		controller.strongestRefreshHeatmapAndRecoverDim();

		reInitializeLeftAllTaskPanes();
	}

	@Override
	public void changeToThisTab() {

	}

	@Override
	public boolean canImport() {
		return true;
	}

	@Override
	public void importData() {
		voicmHeatmapEGPS2.doUserImportAction();
	}

	@Override
	public boolean canExport() {
		return true;
	}

	@Override
	public void exportData() {
		SwingUtilities.invokeLater(() -> {
			controller.saveViewPanelAs();
		});
	}

	@Override
	protected void initializeGraphics() {
		IndependentModuleLoader loader = (IndependentModuleLoader) moduleLoader;

		if (loader.element != null) {
			setDataModel4MatrixAndInitialize(loader.element);
			loader.element = null;
			invokeTheFeatureMethod(0);
			
			howModuleLaunched = "Module launched by direct import required data.";
			whatDataInvoked = "The data is directly import by the developers.";
		} else if (loader.inputContents != null) {
			List<String> contents = loader.inputContents;
			setDataModel4FileContents(contents);
			loader.inputContents = null;
			invokeTheFeatureMethod(1);
			
			howModuleLaunched = "Module launched by click the open button.";
			whatDataInvoked = "The data is loading from the eGPS VOICM import dialog.";
		}

	}

	@Override
	public void invokeTheFeatureMethod(int index) {
		super.invokeTheFeatureMethod(index);
	}

	@Override
	public String[] getFeatureNames() {
		return FEATURES;
	}

	@Override
	public IInformation getModuleInfo() {
		return this;
	}

	@Override
	public String getWhatDataInvoked() {
		return whatDataInvoked;
	}

	@Override
	public String getSummaryOfResults() {
		return summaryOfResults;
	}

	@Override
	public String getHowModuleLaunch() {
		return howModuleLaunched;
	}

	@Override
	public String getHowUserOperates() {
		return leftDataTransFormationPanel.toString().concat(" is applied to the matrix besides the interactive visulization.");
	}
}
